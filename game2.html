<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Ludo 3D Arena - AmÃ©liorÃ©</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap');
    
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    html, body {
      height: 100%;
      overflow: hidden;
      font-family: 'Poppins', sans-serif;
      background: linear-gradient(135deg, #0f1724 0%, #1a2332 100%);
      color: #fff;
      touch-action: none;
    }
    
    #container {
      width: 100vw;
      height: 100vh;
      display: block;
    }
    
    .ui-panel {
      position: fixed;
      top: 10px;
      left: 10px;
      z-index: 100;
      background: rgba(15, 23, 36, 0.95);
      backdrop-filter: blur(10px);
      padding: 12px;
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      border: 1px solid rgba(255, 255, 255, 0.1);
      max-width: calc(100vw - 20px);
    }
    
    .ui-panel h2 {
      font-size: 14px;
      margin-bottom: 10px;
      color: #3b82f6;
      font-weight: 700;
    }
    
    .button-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    button {
      padding: 10px 16px;
      border-radius: 8px;
      border: none;
      background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
      color: #fff;
      cursor: pointer;
      font-family: 'Poppins', sans-serif;
      font-weight: 600;
      font-size: 13px;
      transition: all 0.3s ease;
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
      white-space: nowrap;
      -webkit-tap-highlight-color: transparent;
    }
    
    button:active {
      transform: scale(0.95);
      box-shadow: 0 2px 8px rgba(59, 130, 246, 0.4);
    }
    
    .dice-btn {
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
    }
    
    .dice-btn:active {
      box-shadow: 0 2px 8px rgba(16, 185, 129, 0.4);
    }
    
    .dice-btn:disabled {
      background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);
      cursor: not-allowed;
      opacity: 0.6;
    }
    
    .info-panel {
      position: fixed;
      bottom: 10px;
      right: 10px;
      z-index: 100;
      background: rgba(15, 23, 36, 0.95);
      backdrop-filter: blur(10px);
      padding: 12px 16px;
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      border: 1px solid rgba(255, 255, 255, 0.1);
      max-width: calc(100vw - 20px);
    }
    
    .player-turn {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 8px;
    }
    
    .dice-result {
      font-size: 36px;
      text-align: center;
      margin: 8px 0;
      font-weight: 700;
      text-shadow: 0 0 20px currentColor;
    }
    
    .color-red { color: #ef4444; }
    .color-yellow { color: #fbbf24; }
    .color-green { color: #22c55e; }
    .color-blue { color: #3b82f6; }
    
    .pawn-selector {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 6px;
      margin-top: 10px;
    }
    
    .pawn-btn {
      padding: 8px;
      font-size: 11px;
      border-radius: 6px;
    }
    
    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-2px); }
      75% { transform: translateX(2px); }
    }
    
    .shake {
      animation: shake 0.3s ease-in-out;
    }
    
    /* Responsive pour mobile */
    @media (max-width: 768px) {
      .ui-panel {
        top: 5px;
        left: 5px;
        padding: 10px;
      }
      
      .ui-panel h2 {
        font-size: 12px;
        margin-bottom: 8px;
      }
      
      button {
        padding: 8px 12px;
        font-size: 12px;
      }
      
      .info-panel {
        bottom: 5px;
        right: 5px;
        padding: 10px 12px;
      }
      
      .player-turn {
        font-size: 12px;
      }
      
      .dice-result {
        font-size: 28px;
      }
      
      .pawn-btn {
        padding: 6px;
        font-size: 10px;
      }
    }
  </style>
</head>
<body>
  <div class="ui-panel">
    <h2>ðŸŽ® ContrÃ´les</h2>
    <div class="button-group">
      <button id="resetBtn">ðŸ”„ Vue</button>
      <button id="diceBtn" class="dice-btn">ðŸŽ² Lancer DÃ©</button>
    </div>
  </div>
  
  <div class="info-panel">
    <div class="player-turn">Tour: <span id="currentPlayer" class="color-red">Rouge</span></div>
    <div class="dice-result" id="diceValue">-</div>
    <div id="pawnSelector" class="pawn-selector"></div>
  </div>
  
  <div id="container"></div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.152.2/build/three.module.js"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'https://unpkg.com/three@0.152.2/examples/jsm/controls/OrbitControls.js';

    const container = document.getElementById('container');
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x0f1724, 30, 80);
    
    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
    
    // Ajuster la camÃ©ra pour mobile
    const isMobile = window.innerWidth < 768;
    if (isMobile) {
      camera.position.set(0, 32, 25);
    } else {
      camera.position.set(0, 28, 22);
    }

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    container.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.target.set(0, 0, 0);
    controls.maxPolarAngle = Math.PI / 2.2;
    controls.minDistance = isMobile ? 18 : 15;
    controls.maxDistance = isMobile ? 60 : 50;
    controls.touches = {
      ONE: THREE.TOUCH.ROTATE,
      TWO: THREE.TOUCH.DOLLY_PAN
    };

    // LumiÃ¨res
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);

    const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
    mainLight.position.set(10, 25, 10);
    mainLight.castShadow = true;
    mainLight.shadow.mapSize.width = isMobile ? 1024 : 2048;
    mainLight.shadow.mapSize.height = isMobile ? 1024 : 2048;
    mainLight.shadow.camera.near = 0.5;
    mainLight.shadow.camera.far = 50;
    mainLight.shadow.camera.left = -20;
    mainLight.shadow.camera.right = 20;
    mainLight.shadow.camera.top = 20;
    mainLight.shadow.camera.bottom = -20;
    scene.add(mainLight);

    const fillLight = new THREE.DirectionalLight(0x4a90e2, 0.3);
    fillLight.position.set(-10, 15, -10);
    scene.add(fillLight);

    const SIZE = 15;
    const TILE = 1;

    const COLORS = {
      red: 0xef4444,
      yellow: 0xfbbf24,
      green: 0x22c55e,
      blue: 0x3b82f6,
      path: 0xf8fafc,
      dark: 0x1e293b
    };

    function toPos(col, row) {
      const x = (col - (SIZE + 1) / 2) * TILE;
      const z = (row - (SIZE + 1) / 2) * TILE;
      return { x, z };
    }

    // Sol
    const floorGeo = new THREE.PlaneGeometry(SIZE * TILE + 10, SIZE * TILE + 10);
    const floorMat = new THREE.MeshStandardMaterial({
      color: 0x0a1220,
      metalness: 0.2,
      roughness: 0.8
    });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = -0.5;
    floor.receiveShadow = true;
    scene.add(floor);

    // Base du plateau â€” extrudÃ©e avec un trou central
    const boardBase = new THREE.Group();
    const W = SIZE * TILE + 1;
    const H = SIZE * TILE + 1;
    const depth = 0.8;
    const holeRadius = 1.6; // ajuster la taille du trou central

    // Rectangle shape centered at origin
    const shape = new THREE.Shape();
    shape.moveTo(-W/2, -H/2);
    shape.lineTo(W/2, -H/2);
    shape.lineTo(W/2, H/2);
    shape.lineTo(-W/2, H/2);
    shape.closePath();

    // Hole path (circle) in the center
    const holePath = new THREE.Path();
    holePath.absarc(0, 0, holeRadius, 0, Math.PI * 2, false);
    shape.holes.push(holePath);

    const extrudeSettings = { depth: depth, bevelEnabled: false };
    const baseGeo = new THREE.ExtrudeGeometry(shape, extrudeSettings);
    baseGeo.computeVertexNormals();
    const baseMat = new THREE.MeshStandardMaterial({ color: 0x1e293b, metalness: 0.3, roughness: 0.7 });
    const base = new THREE.Mesh(baseGeo, baseMat);
    // rotate so extrusion depth maps to Y axis and position to match previous base
    base.rotation.x = -Math.PI / 2;
    base.position.y = -depth / 2;
    base.castShadow = true;
    base.receiveShadow = true;
    boardBase.add(base);

    // Bordure restante (anneau extÃ©rieur pour esthÃ©tique)
    const borderGeo = new THREE.BoxGeometry(W + 0.2, 0.3, H + 0.2);
    const borderMat = new THREE.MeshStandardMaterial({ color: 0xfbbf24, metalness: 0.8, roughness: 0.2 });
    const border = new THREE.Mesh(borderGeo, borderMat);
    border.position.y = -0.05;
    border.castShadow = true;
    boardBase.add(border);
    scene.add(boardBase);

    // Tuiles
    const tileGroup = new THREE.Group();
    for (let r = 1; r <= SIZE; r++) {
      for (let c = 1; c <= SIZE; c++) {
        const { x, z } = toPos(c, r);
        const height = isSpecialTile(c, r) ? 0.18 : 0.12;
        const geom = new THREE.BoxGeometry(TILE * 0.96, height, TILE * 0.96);
        const color = determineTileColor(c, r);
        const mat = new THREE.MeshStandardMaterial({
          color,
          metalness: 0.1,
          roughness: 0.6
        });
        const tile = new THREE.Mesh(geom, mat);
        tile.position.set(x, height / 2, z);
        tile.castShadow = true;
        tile.receiveShadow = true;
        tileGroup.add(tile);

        if (isStarTile(c, r)) {
          createStarMarker(x, height + 0.01, z, tileGroup);
        }
      }
    }
    scene.add(tileGroup);

    // Bases des joueurs
    const baseDefs = [
      { name: 'red', cols: [1, 6], rows: [1, 6], color: COLORS.red },
      { name: 'yellow', cols: [10, 15], rows: [1, 6], color: COLORS.yellow },
      { name: 'green', cols: [1, 6], rows: [10, 15], color: COLORS.green },
      { name: 'blue', cols: [10, 15], rows: [10, 15], color: COLORS.blue }
    ];

    const pawns = [];
    baseDefs.forEach((def, baseIndex) => {
      const minC = def.cols[0], maxC = def.cols[1];
      const minR = def.rows[0], maxR = def.rows[1];
      const centerCol = (minC + maxC) / 2;
      const centerRow = (minR + maxR) / 2;
      const p = toPos(centerCol, centerRow);
      const bw = (maxC - minC + 1) * TILE;
      const bh = (maxR - minR + 1) * TILE;

      // Plateforme
      const geo = new THREE.BoxGeometry(bw * 0.92, 0.7, bh * 0.92);
      const mat = new THREE.MeshStandardMaterial({
        color: def.color,
        roughness: 0.4,
        metalness: 0.2
      });
      const platform = new THREE.Mesh(geo, mat);
      platform.position.set(p.x, 0.35, p.z);
      platform.castShadow = true;
      scene.add(platform);

      // LumiÃ¨re
      const baseLight = new THREE.PointLight(def.color, 0.3, 8);
      baseLight.position.set(p.x, 1, p.z);
      scene.add(baseLight);

      // Spawns
      const spawnOffsets = [
        [-1, -1], [1, -1], [-1, 1], [1, 1]
      ];
      spawnOffsets.forEach((so, i) => {
        const sx = p.x + so[0] * 1.2;
        const sz = p.z + so[1] * 1.2;

        const circleGeo = new THREE.CylinderGeometry(0.38, 0.38, 0.08, 32);
        const circleMat = new THREE.MeshStandardMaterial({
          color: 0x347589,
          metalness: 0.5,
          roughness: 0.3
        });
        const mark = new THREE.Mesh(circleGeo, circleMat);
        mark.position.set(sx, 0.4, sz);
        mark.castShadow = true;
        scene.add(mark);

        const pawn = createPawn(def.color);
        pawn.position.set(sx, 0.75, sz);
        scene.add(pawn);
        pawns.push({ 
          mesh: pawn, 
          color: def.name, 
          colorHex: def.color,
          home: { x: sx, z: sz },
          id: baseIndex * 4 + i,
          inPlay: false
        });
      });
    });

    // DÃ©coration centrale
    createCenterDecoration();

    // Ã‰tat du jeu
    let currentPlayerIndex = 0;
    const playerColors = ['red', 'yellow', 'green', 'blue'];
    const playerNames = ['Rouge', 'Jaune', 'Vert', 'Bleu'];
    let diceValue = 0;
    let gameState = 'waiting'; // waiting, rolled, moving

    // Animation
    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      const elapsed = clock.getElapsedTime();

      pawns.forEach((p, i) => {
        if (!p.animating) {
          p.mesh.position.y = p.inPlay ? p.mesh.position.y : 0.75 + Math.sin(elapsed * 2 + i) * 0.03;
          p.mesh.rotation.y = elapsed * 0.5 + i;
        }
      });

      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    // Gestion des Ã©vÃ©nements
    window.addEventListener('resize', () => {
      const newIsMobile = window.innerWidth < 768;
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      
      if (newIsMobile) {
        controls.minDistance = 18;
        controls.maxDistance = 60;
      } else {
        controls.minDistance = 15;
        controls.maxDistance = 50;
      }
    });

    document.getElementById('resetBtn').addEventListener('click', () => {
      const isMob = window.innerWidth < 768;
      camera.position.set(0, isMob ? 32 : 28, isMob ? 25 : 22);
      controls.target.set(0, 0, 0);
    });

    document.getElementById('diceBtn').addEventListener('click', () => {
      if (gameState !== 'waiting') return;
      
      const btn = document.getElementById('diceBtn');
      btn.disabled = true;
      
      // Animation de lancement
      let rolls = 0;
      const rollInterval = setInterval(() => {
        diceValue = Math.floor(Math.random() * 6) + 1;
        document.getElementById('diceValue').textContent = diceValue;
        rolls++;
        
        if (rolls >= 10) {
          clearInterval(rollInterval);
          gameState = 'rolled';
          btn.disabled = false;
          showPawnSelector();
        }
      }, 100);
    });

    function showPawnSelector() {
      const selector = document.getElementById('pawnSelector');
      selector.innerHTML = '';
      
      const currentColor = playerColors[currentPlayerIndex];
      const availablePawns = pawns.filter(p => p.color === currentColor);
      
      availablePawns.forEach((pawn, index) => {
        const btn = document.createElement('button');
        btn.className = 'pawn-btn';
        btn.style.background = `linear-gradient(135deg, ${rgbToHex(pawn.colorHex)} 0%, ${darkenColor(pawn.colorHex)} 100%)`;
        btn.textContent = `P${index + 1}`;
        btn.addEventListener('click', () => movePawn(pawn));
        selector.appendChild(btn);
      });
    }

    function movePawn(pawn) {
      if (gameState !== 'rolled') return;
      
      gameState = 'moving';
      document.getElementById('pawnSelector').innerHTML = '';
      
      // Si le pion est Ã  la maison et qu'on a fait 6, le sortir
      if (!pawn.inPlay && diceValue === 6) {
        const startPos = getStartPosition(pawn.color);
        animatePawnMovement(pawn, startPos.x, startPos.z, () => {
          pawn.inPlay = true;
          nextTurn();
        });
      } else if (pawn.inPlay) {
        // DÃ©placer le pion (simulation simple)
        const currentPos = pawn.mesh.position;
        const newX = currentPos.x + (Math.random() - 0.5) * diceValue * 0.5;
        const newZ = currentPos.z + (Math.random() - 0.5) * diceValue * 0.5;
        
        animatePawnMovement(pawn, newX, newZ, () => {
          nextTurn();
        });
      } else {
        // Ne peut pas bouger
        const diceDisplay = document.getElementById('diceValue');
        diceDisplay.classList.add('shake');
        setTimeout(() => diceDisplay.classList.remove('shake'), 300);
        nextTurn();
      }
    }

    function getStartPosition(color) {
      const startPositions = {
        red: { x: -6, z: -6.5 },
        yellow: { x: 6, z: -6.5 },
        green: { x: -6, z: 6.5 },
        blue: { x: 6, z: 6.5 }
      };
      return startPositions[color];
    }

    function animatePawnMovement(pawn, targetX, targetZ, callback) {
      pawn.animating = true;
      const startX = pawn.mesh.position.x;
      const startZ = pawn.mesh.position.z;
      const startY = pawn.mesh.position.y;
      const jumpHeight = 2;
      const duration = 800;
      const startTime = Date.now();

      function move() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const easeProgress = progress < 0.5
          ? 2 * progress * progress
          : 1 - Math.pow(-2 * progress + 2, 2) / 2;

        pawn.mesh.position.x = startX + (targetX - startX) * easeProgress;
        pawn.mesh.position.z = startZ + (targetZ - startZ) * easeProgress;
        pawn.mesh.position.y = startY + Math.sin(easeProgress * Math.PI) * jumpHeight;

        if (progress < 1) {
          requestAnimationFrame(move);
        } else {
          pawn.mesh.position.y = startY;
          pawn.animating = false;
          if (callback) callback();
        }
      }
      move();
    }

    function nextTurn() {
      // Ne passer au tour suivant que si on n'a pas fait 6
      if (diceValue !== 6) {
        currentPlayerIndex = (currentPlayerIndex + 1) % 4;
      }
      
      const playerSpan = document.getElementById('currentPlayer');
      playerSpan.textContent = playerNames[currentPlayerIndex];
      playerSpan.className = `color-${playerColors[currentPlayerIndex]}`;
      
      diceValue = 0;
      document.getElementById('diceValue').textContent = '-';
      gameState = 'waiting';
    }

    // Fonctions utilitaires
    function determineTileColor(c, r) {
      if (c >= 1 && c <= 6 && r >= 1 && r <= 6) return COLORS.red;
      if (c >= 10 && c <= 15 && r >= 1 && r <= 6) return COLORS.yellow;
      if (c >= 1 && c <= 6 && r >= 10 && r <= 15) return COLORS.green;
      if (c >= 10 && c <= 15 && r >= 10 && r <= 15) return COLORS.blue;
      if (c >= 7 && c <= 9 && r >= 7 && r <= 9) return 0xffffff;

      if (r === 8 && c >= 2 && c <= 6) return 0xfecaca;
      if (r === 8 && c >= 10 && c <= 14) return 0xfef3c7;
      if (c === 8 && r >= 10 && r <= 14) return 0xd1fae5;
      if (c === 8 && r >= 2 && r <= 6) return 0xdbeafe;

      return COLORS.path;
    }

    function isSpecialTile(c, r) {
      return (c === 7 && r === 2) || (c === 2 && r === 9) ||
             (c === 14 && r === 7) || (c === 9 && r === 14);
    }

    function isStarTile(c, r) {
      return (c === 7 && r === 3) || (c === 3 && r === 9) ||
             (c === 13 && r === 7) || (c === 9 && r === 13) ||
             (c === 2 && r === 7) || (c === 7 && r === 2) ||
             (c === 14 && r === 9) || (c === 9 && r === 14);
    }

    function createStarMarker(x, y, z, parent) {
      const starShape = new THREE.Shape();
      const outerRadius = 0.15;
      const innerRadius = 0.06;
      for (let i = 0; i < 10; i++) {
        const radius = i % 2 === 0 ? outerRadius : innerRadius;
        const angle = (i / 10) * Math.PI * 2;
        const px = Math.cos(angle) * radius;
        const py = Math.sin(angle) * radius;
        if (i === 0) starShape.moveTo(px, py);
        else starShape.lineTo(px, py);
      }
      starShape.closePath();

      const starGeo = new THREE.ShapeGeometry(starShape);
      const starMat = new THREE.MeshStandardMaterial({
        color: 0xfbbf24,
        metalness: 0.8,
        roughness: 0.2
      });
      const star = new THREE.Mesh(starGeo, starMat);
      star.rotation.x = -Math.PI / 2;
      star.position.set(x, y, z);
      parent.add(star);
    }

    function createPawn(color) {
      const group = new THREE.Group();

      const bodyGeo = new THREE.CylinderGeometry(0.3, 0.4, 0.7, 32);
      const bodyMat = new THREE.MeshStandardMaterial({
        color,
        metalness: 0.3,
        roughness: 0.5
      });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.castShadow = true;
      group.add(body);

      const headGeo = new THREE.SphereGeometry(0.25, 32, 32);
      const head = new THREE.Mesh(headGeo, bodyMat);
      head.position.y = 0.55;
      head.castShadow = true;
      group.add(head);

      return group;
    }

    function createCenterDecoration() {
      const triSize = 2.4;
      const positions = [
        { x: -1.2, z: -1.2, rot: Math.PI * 0.25, color: COLORS.red },
        { x: 1.2, z: -1.2, rot: Math.PI * -0.25, color: COLORS.yellow },
        { x: -1.2, z: 1.2, rot: Math.PI * 0.75, color: COLORS.green },
        { x: 1.2, z: 1.2, rot: Math.PI * -0.75, color: COLORS.blue }
      ];

      positions.forEach(pos => {
        const triGeo = new THREE.CylinderGeometry(0, triSize, 0.15, 3);
        const triMat = new THREE.MeshStandardMaterial({
          color: pos.color,
          metalness: 0.4,
          roughness: 0.6
        });
        const tri = new THREE.Mesh(triGeo, triMat);
        tri.position.set(pos.x, 0.08, pos.z);
        tri.rotation.y = pos.rot;
        tri.castShadow = true;
        scene.add(tri);
      });

      const circGeo = new THREE.CylinderGeometry(0.7, 0.7, 0.12, 32);
      const circMat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        metalness: 0.6,
        roughness: 0.3
      });
      const circ = new THREE.Mesh(circGeo, circMat);
      circ.position.set(0, 0.1, 0);
      circ.castShadow = true;
      scene.add(circ);
    }

    function rgbToHex(hex) {
      return '#' + hex.toString(16).padStart(6, '0');
    }

    function darkenColor(hex) {
      const r = (hex >> 16) & 0xff;
      const g = (hex >> 8) & 0xff;
      const b = hex & 0xff;
      return '#' + ((r * 0.7) << 16 | (g * 0.7) << 8 | (b * 0.7)).toString(16).padStart(6, '0');
    }

  </script>
</body>
</html>