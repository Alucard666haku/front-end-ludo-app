<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Ludo 3D Arena - Configurable</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap');
    
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    html, body {
      height: 100%;
      overflow: hidden;
      font-family: 'Poppins', sans-serif;
      background: linear-gradient(135deg, #0f1724 0%, #1a2332 100%);
      color: #fff;
      touch-action: none;
    }
    
    #container {
      width: 100vw;
      height: 100vh;
      display: block;
      opacity: 0;
      transition: opacity 0.5s ease;
    }
    
    #container.visible {
      opacity: 1;
    }
    
    /* Configuration Menu */
    .config-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(15, 23, 36, 0.98);
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(10px);
    }
    
    .config-overlay.hidden {
      display: none;
    }
    
    .config-panel {
      background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
      padding: 40px;
      border-radius: 20px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6);
      border: 2px solid rgba(59, 130, 246, 0.3);
      max-width: 500px;
      width: 90%;
      max-height: 90vh;
      overflow-y: auto;
    }
    
    .config-panel h1 {
      font-size: 28px;
      margin-bottom: 10px;
      color: #3b82f6;
      text-align: center;
    }
    
    .config-panel p {
      text-align: center;
      margin-bottom: 30px;
      color: #94a3b8;
      font-size: 14px;
    }
    
    .config-group {
      margin-bottom: 25px;
    }
    
    .config-group label {
      display: block;
      margin-bottom: 10px;
      font-weight: 600;
      color: #e2e8f0;
      font-size: 14px;
    }
    
    .config-group input[type="range"] {
      width: 100%;
      padding: 0;
      height: 8px;
      -webkit-appearance: none;
      appearance: none;
      background: rgba(59, 130, 246, 0.3);
      outline: none;
      border-radius: 5px;
      border: none;
    }
    
    .config-group input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: linear-gradient(135deg, #3b82f6, #2563eb);
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(59, 130, 246, 0.5);
    }
    
    .config-group input[type="range"]::-moz-range-thumb {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: linear-gradient(135deg, #3b82f6, #2563eb);
      cursor: pointer;
      border: none;
      box-shadow: 0 2px 8px rgba(59, 130, 246, 0.5);
    }
    
    .range-value {
      display: inline-block;
      margin-left: 10px;
      color: #3b82f6;
      font-weight: 700;
      font-size: 18px;
    }
    
    .player-selector {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      margin-top: 10px;
    }
    
    .player-option {
      padding: 15px;
      border-radius: 10px;
      border: 2px solid rgba(59, 130, 246, 0.3);
      background: rgba(15, 23, 36, 0.6);
      cursor: pointer;
      text-align: center;
      font-weight: 600;
      transition: all 0.3s ease;
    }
    
    .player-option:hover {
      border-color: #3b82f6;
      background: rgba(59, 130, 246, 0.2);
      transform: translateY(-2px);
    }
    
    .player-option.selected {
      border-color: #3b82f6;
      background: linear-gradient(135deg, #3b82f6, #2563eb);
      color: #fff;
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.5);
    }
    
    .start-btn {
      width: 100%;
      padding: 15px;
      border-radius: 12px;
      border: none;
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      color: #fff;
      cursor: pointer;
      font-family: 'Poppins', sans-serif;
      font-weight: 700;
      font-size: 18px;
      margin-top: 30px;
      box-shadow: 0 6px 20px rgba(16, 185, 129, 0.4);
      transition: all 0.3s ease;
    }
    
    .start-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 30px rgba(16, 185, 129, 0.6);
    }
    
    .start-btn:active {
      transform: translateY(0);
    }
    
    .ui-panel {
      position: fixed;
      top: 10px;
      left: 10px;
      z-index: 100;
      background: rgba(15, 23, 36, 0.95);
      backdrop-filter: blur(10px);
      padding: 12px;
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      border: 1px solid rgba(255, 255, 255, 0.1);
      max-width: calc(100vw - 20px);
    }
    
    .ui-panel h2 {
      font-size: 14px;
      margin-bottom: 10px;
      color: #3b82f6;
      font-weight: 700;
    }
    
    .button-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    button {
      padding: 10px 16px;
      border-radius: 8px;
      border: none;
      background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
      color: #fff;
      cursor: pointer;
      font-family: 'Poppins', sans-serif;
      font-weight: 600;
      font-size: 13px;
      transition: all 0.3s ease;
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
      white-space: nowrap;
      -webkit-tap-highlight-color: transparent;
    }
    
    button:active {
      transform: scale(0.95);
      box-shadow: 0 2px 8px rgba(59, 130, 246, 0.4);
    }
    
    .dice-btn {
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
    }
    
    .dice-btn:disabled {
      background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);
      cursor: not-allowed;
      opacity: 0.6;
    }
    
    .info-panel {
      position: fixed;
      bottom: 10px;
      right: 10px;
      z-index: 100;
      background: rgba(15, 23, 36, 0.95);
      backdrop-filter: blur(10px);
      padding: 12px 16px;
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      border: 1px solid rgba(255, 255, 255, 0.1);
      max-width: calc(100vw - 20px);
    }
    
    .player-turn {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 8px;
    }
    
    .dice-result {
      font-size: 36px;
      text-align: center;
      margin: 8px 0;
      font-weight: 700;
      text-shadow: 0 0 20px currentColor;
    }
    
    .pawn-selector {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 6px;
      margin-top: 10px;
    }
    
    .pawn-btn {
      padding: 8px;
      font-size: 11px;
      border-radius: 6px;
    }
    
    .color-red { color: #ef4444; }
    .color-yellow { color: #fbbf24; }
    .color-green { color: #22c55e; }
    .color-blue { color: #3b82f6; }
    .color-violet { color: #a855f7; }
    .color-orange { color: #f97316; }
    .color-pink { color: #ec4899; }
    .color-cyan { color: #06b6d4; }
    
    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-2px); }
      75% { transform: translateX(2px); }
    }
    
    .shake {
      animation: shake 0.3s ease-in-out;
    }
    
    @media (max-width: 768px) {
      .config-panel {
        padding: 25px;
      }
      
      .config-panel h1 {
        font-size: 22px;
      }
      
      .player-selector {
        grid-template-columns: repeat(2, 1fr);
      }
    }
  </style>
</head>
<body>
  <div class="config-overlay" id="configOverlay">
    <div class="config-panel">
      <h1>üé≤ Configuration du Ludo 3D</h1>
      <p>Personnalisez votre partie</p>
      
      <div class="config-group">
        <label>Nombre de Joueurs (3-8)</label>
        <div class="player-selector" id="playerSelector">
          <div class="player-option" data-players="3">3 Joueurs<br>‚ñ≥ Triangle</div>
          <div class="player-option selected" data-players="4">4 Joueurs<br>‚ñ° Carr√©</div>
          <div class="player-option" data-players="5">5 Joueurs<br>‚¨† Pentagon</div>
          <div class="player-option" data-players="6">6 Joueurs<br>‚¨° Hexagone</div>
          <div class="player-option" data-players="7">7 Joueurs<br>Heptagone</div>
          <div class="player-option" data-players="8">8 Joueurs<br>Octogone</div>
        </div>
      </div>
      
      <div class="config-group">
        <label>Nombre de Pions par Joueur <span class="range-value" id="pawnsValue">4</span></label>
        <input type="range" id="pawnsSlider" min="2" max="6" value="4" step="1">
      </div>
      
      <div class="config-group">
        <label>Longueur du Chemin Color√© <span class="range-value" id="pathValue">5</span></label>
        <input type="range" id="pathSlider" min="3" max="10" value="5" step="1">
      </div>
      
      <button class="start-btn" id="startGameBtn">üöÄ Commencer la Partie</button>
    </div>
  </div>
  
  <div class="ui-panel">
    <h2>üéÆ Contr√¥les</h2>
    <div class="button-group">
      <button id="resetBtn">üîÑ Vue</button>
      <button id="diceBtn" class="dice-btn">üé≤ Lancer D√©</button>
      <button id="reconfigBtn">‚öôÔ∏è Reconfigurer</button>
    </div>
  </div>
  
  <div class="info-panel">
    <div class="player-turn">Tour: <span id="currentPlayer">-</span></div>
    <div class="dice-result" id="diceValue">-</div>
    <div id="pawnSelector" class="pawn-selector"></div>
  </div>
  
  <div id="container"></div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.152.2/build/three.module.js"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'https://unpkg.com/three@0.152.2/examples/jsm/controls/OrbitControls.js';

// Configuration
let gameConfig = {
  numPlayers: 4,
  pawnsPerPlayer: 4,
  pathLength: 5
};

const PLAYER_COLORS = [
  { name: 'Rouge', hex: 0xef4444, cssClass: 'color-red' },
  { name: 'Jaune', hex: 0xfbbf24, cssClass: 'color-yellow' },
  { name: 'Vert', hex: 0x22c55e, cssClass: 'color-green' },
  { name: 'Bleu', hex: 0x3b82f6, cssClass: 'color-blue' },
  { name: 'Violet', hex: 0xa855f7, cssClass: 'color-violet' },
  { name: 'Orange', hex: 0xf97316, cssClass: 'color-orange' },
  { name: 'Rose', hex: 0xec4899, cssClass: 'color-pink' },
  { name: 'Cyan', hex: 0x06b6d4, cssClass: 'color-cyan' }
];

// Variables globales
const container = document.getElementById('container');
let scene, camera, renderer, controls;
let pawns = [];
let currentPlayerIndex = 0;
let diceValue = 0;
let gameState = 'waiting';

// Configuration UI
const playerOptions = document.querySelectorAll('.player-option');
playerOptions.forEach(option => {
  option.addEventListener('click', () => {
    playerOptions.forEach(o => o.classList.remove('selected'));
    option.classList.add('selected');
    gameConfig.numPlayers = parseInt(option.dataset.players);
  });
});

document.getElementById('pawnsSlider').addEventListener('input', (e) => {
  gameConfig.pawnsPerPlayer = parseInt(e.target.value);
  document.getElementById('pawnsValue').textContent = e.target.value;
});

document.getElementById('pathSlider').addEventListener('input', (e) => {
  gameConfig.pathLength = parseInt(e.target.value);
  document.getElementById('pathValue').textContent = e.target.value;
});

document.getElementById('startGameBtn').addEventListener('click', () => {
  document.getElementById('configOverlay').classList.add('hidden');
  document.getElementById('container').classList.add('visible');
  initGame();
});

document.getElementById('reconfigBtn').addEventListener('click', () => {
  location.reload();
});

function initGame() {
  scene = new THREE.Scene();
  scene.fog = new THREE.Fog(0x0f1724, 30, 100);
  
  camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
  
  const cameraDistance = 15 + gameConfig.numPlayers * 2;
  camera.position.set(0, cameraDistance * 1.2, cameraDistance);

  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  container.appendChild(renderer.domElement);

  controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;
  controls.target.set(0, 0, 0);
  controls.maxPolarAngle = Math.PI / 2.2;
  controls.minDistance = 10;
  controls.maxDistance = cameraDistance * 2;
  controls.touches = {
    ONE: THREE.TOUCH.ROTATE,
    TWO: THREE.TOUCH.DOLLY_PAN
  };

  setupLights();
  createBoard();
  setupEventListeners();
  animate();
  updatePlayerTurn();
}

function setupLights() {
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
  scene.add(ambientLight);

  const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
  mainLight.position.set(10, 25, 10);
  mainLight.castShadow = true;
  mainLight.shadow.mapSize.width = 2048;
  mainLight.shadow.mapSize.height = 2048;
  mainLight.shadow.camera.near = 0.5;
  mainLight.shadow.camera.far = 50;
  mainLight.shadow.camera.left = -30;
  mainLight.shadow.camera.right = 30;
  mainLight.shadow.camera.top = 30;
  mainLight.shadow.camera.bottom = -30;
  scene.add(mainLight);

  const fillLight = new THREE.DirectionalLight(0x4a90e2, 0.3);
  fillLight.position.set(-10, 15, -10);
  scene.add(fillLight);
}

function createBoard() {
  const boardSize = 12 + gameConfig.pathLength * 2;
  
  const floorGeo = new THREE.PlaneGeometry(boardSize * 2.5, boardSize * 2.5);
  const floorMat = new THREE.MeshStandardMaterial({
    color: 0x0a1220,
    metalness: 0.2,
    roughness: 0.8
  });
  const floor = new THREE.Mesh(floorGeo, floorMat);
  floor.rotation.x = -Math.PI / 2;
  floor.position.y = -0.5;
  floor.receiveShadow = true;
  scene.add(floor);

  createPolygonBoard();
}

function createPolygonBoard() {
  const numPlayers = gameConfig.numPlayers;
  const radius = 8 + gameConfig.pathLength * 0.5;
  const angleStep = (Math.PI * 2) / numPlayers;
  
  const shape = new THREE.Shape();
  for (let i = 0; i < numPlayers; i++) {
    const angle = i * angleStep - Math.PI / 2;
    const x = Math.cos(angle) * radius;
    const z = Math.sin(angle) * radius;
    if (i === 0) shape.moveTo(x, z);
    else shape.lineTo(x, z);
  }
  shape.closePath();

  const extrudeSettings = {
    depth: 0.8,
    bevelEnabled: true,
    bevelThickness: 0.1,
    bevelSize: 0.1,
    bevelSegments: 3
  };

  const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
  const material = new THREE.MeshStandardMaterial({
    color: 0x1e293b,
    metalness: 0.3,
    roughness: 0.7
  });
  const board = new THREE.Mesh(geometry, material);
  board.rotation.x = -Math.PI / 2;
  board.position.y = -0.4;
  board.castShadow = true;
  board.receiveShadow = true;
  scene.add(board);

  const borderShape = new THREE.Shape();
  const borderRadius = radius + 0.3;
  for (let i = 0; i < numPlayers; i++) {
    const angle = i * angleStep - Math.PI / 2;
    const x = Math.cos(angle) * borderRadius;
    const z = Math.sin(angle) * borderRadius;
    if (i === 0) borderShape.moveTo(x, z);
    else borderShape.lineTo(x, z);
  }
  borderShape.closePath();

  const borderGeo = new THREE.ExtrudeGeometry(borderShape, { depth: 0.3 });
  const borderMat = new THREE.MeshStandardMaterial({
    color: 0xfbbf24,
    metalness: 0.8,
    roughness: 0.2
  });
  const border = new THREE.Mesh(borderGeo, borderMat);
  border.rotation.x = -Math.PI / 2;
  border.position.y = -0.05;
  border.castShadow = true;
  scene.add(border);

  createPlayerBases(radius, angleStep);
  createCenterDecoration();
}

function createPlayerBases(radius, angleStep) {
  for (let i = 0; i < gameConfig.numPlayers; i++) {
    const angle = i * angleStep - Math.PI / 2;
    const baseRadius = 2.5;
    const baseDistance = radius * 0.7;
    const x = Math.cos(angle) * baseDistance;
    const z = Math.sin(angle) * baseDistance;
    
    const playerColor = PLAYER_COLORS[i];
    
    const baseGeo = new THREE.CylinderGeometry(baseRadius, baseRadius, 0.6, 32);
    const baseMat = new THREE.MeshStandardMaterial({
      color: playerColor.hex,
      roughness: 0.4,
      metalness: 0.2
    });
    const base = new THREE.Mesh(baseGeo, baseMat);
    base.position.set(x, 0.3, z);
    base.castShadow = true;
    scene.add(base);

    const baseLight = new THREE.PointLight(playerColor.hex, 0.3, 8);
    baseLight.position.set(x, 1, z);
    scene.add(baseLight);

    createPathTiles(x, z, angle, playerColor.hex);
    createPawnsForPlayer(i, x, z, baseRadius, playerColor);
  }
}

function createPathTiles(baseX, baseZ, angle, color) {
  const pathLength = gameConfig.pathLength;
  const tileSize = 0.8;
  const spacing = 1;
  
  for (let j = 1; j <= pathLength; j++) {
    const dist = 3.5 + j * spacing;
    const tileX = baseX + Math.cos(angle) * dist;
    const tileZ = baseZ + Math.sin(angle) * dist;
    
    const tileGeo = new THREE.BoxGeometry(tileSize, 0.15, tileSize);
    const tileMat = new THREE.MeshStandardMaterial({
      color: color,
      metalness: 0.1,
      roughness: 0.6,
      opacity: 0.7,
      transparent: true
    });
    const tile = new THREE.Mesh(tileGeo, tileMat);
    tile.position.set(tileX, 0.08, tileZ);
    tile.castShadow = true;
    tile.receiveShadow = true;
    scene.add(tile);
  }
}

function createPawnsForPlayer(playerIndex, baseX, baseZ, baseRadius, playerColor) {
  const pawnsPerPlayer = gameConfig.pawnsPerPlayer;
  const angleStep = (Math.PI * 2) / pawnsPerPlayer;
  
  for (let i = 0; i < pawnsPerPlayer; i++) {
    const angle = i * angleStep;
    const spawnRadius = baseRadius * 0.6;
    const sx = baseX + Math.cos(angle) * spawnRadius;
    const sz = baseZ + Math.sin(angle) * spawnRadius;
    
    const circleGeo = new THREE.CylinderGeometry(0.35, 0.35, 0.08, 32);
    const circleMat = new THREE.MeshStandardMaterial({
      color: 0x347589,
      metalness: 0.5,
      roughness: 0.3
    });
    const mark = new THREE.Mesh(circleGeo, circleMat);
    mark.position.set(sx, 0.35, sz);
    mark.castShadow = true;
    scene.add(mark);

    const pawn = createPawn(playerColor.hex);
    pawn.position.set(sx, 0.7, sz);
    scene.add(pawn);
    
    pawns.push({
      mesh: pawn,
      playerIndex: playerIndex,
      colorHex: playerColor.hex,
      colorName: playerColor.name,
      cssClass: playerColor.cssClass,
      home: { x: sx, z: sz },
      id: playerIndex * pawnsPerPlayer + i,
      inPlay: false
    });
  }
}

function createPawn(color) {
  const group = new THREE.Group();

  const bodyGeo = new THREE.CylinderGeometry(0.28, 0.36, 0.65, 32);
  const bodyMat = new THREE.MeshStandardMaterial({
    color,
    metalness: 0.3,
    roughness: 0.5
  });
  const body = new THREE.Mesh(bodyGeo, bodyMat);
  body.castShadow = true;
  group.add(body);

  const headGeo = new THREE.SphereGeometry(0.22, 32, 32);
  const head = new THREE.Mesh(headGeo, bodyMat);
  head.position.y = 0.5;
  head.castShadow = true;
  group.add(head);

  return group;
}

function createCenterDecoration() {
  const holeDepth = 0.8;
  const holeRadius = 1.2;
  
  const holeGeo = new THREE.CylinderGeometry(holeRadius, holeRadius * 0.9, holeDepth, 32);
  const holeMat = new THREE.MeshStandardMaterial({
    color: 0x000000,
    metalness: 0.1,
    roughness: 0.95,
    emissive: 0x000000
  });
  const hole = new THREE.Mesh(holeGeo, holeMat);
  hole.position.set(0, -holeDepth / 2 + 0.02, 0);
  hole.receiveShadow = true;
  scene.add(hole);

  const shadowRingGeo = new THREE.CylinderGeometry(holeRadius + 0.1, holeRadius, 0.1, 32);
  const shadowRingMat = new THREE.MeshStandardMaterial({
    color: 0x0a0a0a,
    metalness: 0.2,
    roughness: 0.9
  });
  const shadowRing = new THREE.Mesh(shadowRingGeo, shadowRingMat);
  shadowRing.position.set(0, 0.02, 0);
  scene.add(shadowRing);

  const rimLight = new THREE.PointLight(0x3b82f6, 0.2, 5);
  rimLight.position.set(0, 0.1, 0);
  scene.add(rimLight);
}

function animate() {
  requestAnimationFrame(animate);
  const elapsed = performance.now() * 0.001;

  pawns.forEach((p, i) => {
    if (!p.animating) {
      p.mesh.position.y = p.inPlay ? p.mesh.position.y : 0.7 + Math.sin(elapsed * 2 + i) * 0.03;
      p.mesh.rotation.y = elapsed * 0.5 + i;
    }
  });

  controls.update();
  renderer.render(scene, camera);
}

function setupEventListeners() {
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  document.getElementById('resetBtn').addEventListener('click', () => {
    const cameraDistance = 15 + gameConfig.numPlayers * 2;
    camera.position.set(0, cameraDistance * 1.2, cameraDistance);
    controls.target.set(0, 0, 0);
  });

  document.getElementById('diceBtn').addEventListener('click', () => {
    if (gameState !== 'waiting') return;
    
    const btn = document.getElementById('diceBtn');
    btn.disabled = true;
    
    let rolls = 0;
    const rollInterval = setInterval(() => {
      diceValue = Math.floor(Math.random() * 6) + 1;
      document.getElementById('diceValue').textContent = diceValue;
      rolls++;
      
      if (rolls >= 10) {
        clearInterval(rollInterval);
        gameState = 'rolled';
        btn.disabled = false;
        showPawnSelector();
      }
    }, 100);
  });
}

function showPawnSelector() {
  const selector = document.getElementById('pawnSelector');
  selector.innerHTML = '';
  
  const availablePawns = pawns.filter(p => p.playerIndex === currentPlayerIndex);
  
  availablePawns.forEach((pawn, index) => {
    const btn = document.createElement('button');
    btn.className = 'pawn-btn';
    btn.style.background = `linear-gradient(135deg, ${rgbToHex(pawn.colorHex)} 0%, ${darkenColor(pawn.colorHex)} 100%)`;
    btn.textContent = `P${index + 1}`;
    btn.addEventListener('click', () => movePawn(pawn));
    selector.appendChild(btn);
  });
}

function movePawn(pawn) {
  if (gameState !== 'rolled') return;
  
  gameState = 'moving';
  document.getElementById('pawnSelector').innerHTML = '';
  
  if (!pawn.inPlay && diceValue === 6) {
    const startPos = getStartPosition(pawn.playerIndex);
    animatePawnMovement(pawn, startPos.x, startPos.z, () => {
      pawn.inPlay = true;
      nextTurn();
    });
  } else if (pawn.inPlay) {
    const currentPos = pawn.mesh.position;
    const newX = currentPos.x + (Math.random() - 0.5) * diceValue * 0.5;
    const newZ = currentPos.z + (Math.random() - 0.5) * diceValue * 0.5;
    
    animatePawnMovement(pawn, newX, newZ, () => {
      nextTurn();
    });
  } else {
    const diceDisplay = document.getElementById('diceValue');
    diceDisplay.classList.add('shake');
    setTimeout(() => diceDisplay.classList.remove('shake'), 300);
    nextTurn();
  }
}

function getStartPosition(playerIndex) {
  const angleStep = (Math.PI * 2) / gameConfig.numPlayers;
  const angle = playerIndex * angleStep - Math.PI / 2;
  const radius = 8 + gameConfig.pathLength * 0.5;
  const baseDistance = radius * 0.7;
  const startDist = 3.5;
  
  const baseX = Math.cos(angle) * baseDistance;
  const baseZ = Math.sin(angle) * baseDistance;
  
  return {
    x: baseX + Math.cos(angle) * startDist,
    z: baseZ + Math.sin(angle) * startDist
  };
}

function animatePawnMovement(pawn, targetX, targetZ, callback) {
  pawn.animating = true;
  const startX = pawn.mesh.position.x;
  const startZ = pawn.mesh.position.z;
  const startY = pawn.mesh.position.y;
  const jumpHeight = 2;
  const duration = 800;
  const startTime = Date.now();

  function move() {
    const elapsed = Date.now() - startTime;
    const progress = Math.min(elapsed / duration, 1);
    const easeProgress = progress < 0.5
      ? 2 * progress * progress
      : 1 - Math.pow(-2 * progress + 2, 2) / 2;

    pawn.mesh.position.x = startX + (targetX - startX) * easeProgress;
    pawn.mesh.position.z = startZ + (targetZ - startZ) * easeProgress;
    pawn.mesh.position.y = startY + Math.sin(easeProgress * Math.PI) * jumpHeight;

    if (progress < 1) {
      requestAnimationFrame(move);
    } else {
      pawn.mesh.position.y = startY;
      pawn.animating = false;
      if (callback) callback();
    }
  }
  move();
}

function nextTurn() {
  if (diceValue !== 6) {
    currentPlayerIndex = (currentPlayerIndex + 1) % gameConfig.numPlayers;
  }
  
  updatePlayerTurn();
  
  diceValue = 0;
  document.getElementById('diceValue').textContent = '-';
  gameState = 'waiting';
}

function updatePlayerTurn() {
  const currentPlayer = PLAYER_COLORS[currentPlayerIndex];
  const playerSpan = document.getElementById('currentPlayer');
  playerSpan.textContent = currentPlayer.name;
  playerSpan.className = currentPlayer.cssClass;
}

function rgbToHex(hex) {
  return '#' + hex.toString(16).padStart(6, '0');
}

function darkenColor(hex) {
  const r = (hex >> 16) & 0xff;
  const g = (hex >> 8) & 0xff;
  const b = hex & 0xff;
  return '#' + ((r * 0.7) << 16 | (g * 0.7) << 8 | (b * 0.7)).toString(16).padStart(6, '0');
}
</script>
</body>
</html>