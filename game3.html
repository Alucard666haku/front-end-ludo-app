<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Ludo 3D Arena - Configurable</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap');
    
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    html, body {
      height: 100%;
      overflow: hidden;
      font-family: 'Poppins', sans-serif;
      background: linear-gradient(135deg, #0f1724 0%, #1a2332 100%);
      color: #fff;
      touch-action: none;
    }
    
    #container {
      width: 100vw;
      height: 100vh;
      display: block;
      opacity: 0;
      transition: opacity 0.5s ease;
    }
    
    #container.visible {
      opacity: 1;
    }
    
    /* Configuration Menu */
    .config-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(15, 23, 36, 0.98);
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(10px);
    }
    
    .config-overlay.hidden {
      display: none;
    }
    
    .config-panel {
      background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
      padding: 40px;
      border-radius: 20px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6);
      border: 2px solid rgba(59, 130, 246, 0.3);
      max-width: 500px;
      width: 90%;
      max-height: 90vh;
      overflow-y: auto;
    }
    
    .config-panel h1 {
      font-size: 28px;
      margin-bottom: 10px;
      color: #3b82f6;
      text-align: center;
    }
    
    .config-panel p {
      text-align: center;
      margin-bottom: 30px;
      color: #94a3b8;
      font-size: 14px;
    }
    
    .config-group {
      margin-bottom: 25px;
    }
    
    .config-group label {
      display: block;
      margin-bottom: 10px;
      font-weight: 600;
      color: #e2e8f0;
      font-size: 14px;
    }
    
    .config-group input[type="range"] {
      width: 100%;
      padding: 0;
      height: 8px;
      -webkit-appearance: none;
      appearance: none;
      background: rgba(59, 130, 246, 0.3);
      outline: none;
      border-radius: 5px;
      border: none;
    }
    
    .config-group input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: linear-gradient(135deg, #3b82f6, #2563eb);
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(59, 130, 246, 0.5);
    }
    
    .config-group input[type="range"]::-moz-range-thumb {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: linear-gradient(135deg, #3b82f6, #2563eb);
      cursor: pointer;
      border: none;
      box-shadow: 0 2px 8px rgba(59, 130, 246, 0.5);
    }
    
    .range-value {
      display: inline-block;
      margin-left: 10px;
      color: #3b82f6;
      font-weight: 700;
      font-size: 18px;
    }
    
    .player-selector {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      margin-top: 10px;
    }
    
    .player-option {
      padding: 15px;
      border-radius: 10px;
      border: 2px solid rgba(59, 130, 246, 0.3);
      background: rgba(15, 23, 36, 0.6);
      cursor: pointer;
      text-align: center;
      font-weight: 600;
      transition: all 0.3s ease;
    }
    
    .player-option:hover {
      border-color: #3b82f6;
      background: rgba(59, 130, 246, 0.2);
      transform: translateY(-2px);
    }
    
    .player-option.selected {
      border-color: #3b82f6;
      background: linear-gradient(135deg, #3b82f6, #2563eb);
      color: #fff;
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.5);
    }
    
    .start-btn {
      width: 100%;
      padding: 15px;
      border-radius: 12px;
      border: none;
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      color: #fff;
      cursor: pointer;
      font-family: 'Poppins', sans-serif;
      font-weight: 700;
      font-size: 18px;
      margin-top: 30px;
      box-shadow: 0 6px 20px rgba(16, 185, 129, 0.4);
      transition: all 0.3s ease;
    }
    
    .start-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 30px rgba(16, 185, 129, 0.6);
    }
    
    .start-btn:active {
      transform: translateY(0);
    }
    
    .ui-panel {
      position: fixed;
      top: 10px;
      left: 10px;
      z-index: 100;
      background: rgba(15, 23, 36, 0.95);
      backdrop-filter: blur(10px);
      padding: 12px;
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      border: 1px solid rgba(255, 255, 255, 0.1);
      max-width: calc(100vw - 20px);
    }
    
    .ui-panel h2 {
      font-size: 14px;
      margin-bottom: 10px;
      color: #3b82f6;
      font-weight: 700;
    }
    
    .button-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    button {
      padding: 10px 16px;
      border-radius: 8px;
      border: none;
      background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
      color: #fff;
      cursor: pointer;
      font-family: 'Poppins', sans-serif;
      font-weight: 600;
      font-size: 13px;
      transition: all 0.3s ease;
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
      white-space: nowrap;
      -webkit-tap-highlight-color: transparent;
    }
    
    button:active {
      transform: scale(0.95);
      box-shadow: 0 2px 8px rgba(59, 130, 246, 0.4);
    }
    
    .dice-btn {
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
    }
    
    .dice-btn:disabled {
      background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);
      cursor: not-allowed;
      opacity: 0.6;
    }
    
    .info-panel {
      position: fixed;
      bottom: 10px;
      right: 10px;
      z-index: 100;
      background: rgba(15, 23, 36, 0.95);
      backdrop-filter: blur(10px);
      padding: 12px 16px;
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      border: 1px solid rgba(255, 255, 255, 0.1);
      max-width: calc(100vw - 20px);
    }
    
    .player-turn {
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 8px;
    }
    
    .dice-result {
      font-size: 36px;
      text-align: center;
      margin: 8px 0;
      font-weight: 700;
      text-shadow: 0 0 20px currentColor;
    }
    
    .pawn-selector {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 6px;
      margin-top: 10px;
    }
    
    .pawn-btn {
      padding: 8px;
      font-size: 11px;
      border-radius: 6px;
    }
    
    .color-red { color: #ef4444; }
    .color-yellow { color: #fbbf24; }
    .color-green { color: #22c55e; }
    .color-blue { color: #3b82f6; }
    .color-violet { color: #a855f7; }
    .color-orange { color: #f97316; }
    .color-pink { color: #ec4899; }
    .color-cyan { color: #06b6d4; }
    
    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-2px); }
      75% { transform: translateX(2px); }
    }
    
    .shake {
      animation: shake 0.3s ease-in-out;
    }
    
    @media (max-width: 768px) {
      .config-panel {
        padding: 25px;
      }
      
      .config-panel h1 {
        font-size: 22px;
      }
      
      .player-selector {
        grid-template-columns: repeat(2, 1fr);
      }
    }
  </style>
</head>
<body>
  <div class="config-overlay" id="configOverlay">
    <div class="config-panel">
      <h1>üé≤ Configuration du Ludo 3D</h1>
      <p>Personnalisez votre partie</p>
      
      <div class="config-group">
        <label>Nombre de Joueurs (3-8)</label>
        <div class="player-selector" id="playerSelector">
          <div class="player-option" data-players="3">3 Joueurs<br>‚ñ≥ Triangle</div>
          <div class="player-option selected" data-players="4">4 Joueurs<br>‚ñ° Carr√©</div>
          <div class="player-option" data-players="5">5 Joueurs<br>‚¨† Pentagon</div>
          <div class="player-option" data-players="6">6 Joueurs<br>‚¨° Hexagone</div>
          <div class="player-option" data-players="7">7 Joueurs<br>Heptagone</div>
          <div class="player-option" data-players="8">8 Joueurs<br>Octogone</div>
        </div>
      </div>
      
      <div class="config-group">
        <label>Nombre de Pions par Joueur <span class="range-value" id="pawnsValue">4</span></label>
        <input type="range" id="pawnsSlider" min="2" max="6" value="4" step="1">
      </div>
      
      <div class="config-group">
        <label>Longueur du Chemin Color√© <span class="range-value" id="pathValue">5</span></label>
        <input type="range" id="pathSlider" min="3" max="10" value="5" step="1">
      </div>
      
      <button class="start-btn" id="startGameBtn">üöÄ Commencer la Partie</button>
    </div>
  </div>
  
  <div class="ui-panel">
    <h2>üéÆ Contr√¥les</h2>
    <div class="button-group">
      <button id="resetBtn">üîÑ Vue</button>
      <button id="diceBtn" class="dice-btn">üé≤ Lancer D√©</button>
      <button id="reconfigBtn">‚öôÔ∏è Reconfigurer</button>
    </div>
  </div>
  
  <div class="info-panel">
    <div class="player-turn">Tour: <span id="currentPlayer">-</span></div>
    <div class="dice-result" id="diceValue">-</div>
    <div id="pawnSelector" class="pawn-selector"></div>
  </div>
  
  <div id="container"></div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.152.2/build/three.module.js"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
import { OrbitControls } from 'https://unpkg.com/three@0.152.2/examples/jsm/controls/OrbitControls.js';

// Configuration
let gameConfig = {
  numPlayers: 4,
  pawnsPerPlayer: 4,
  pathLength: 5
};

const PLAYER_COLORS = [
  { name: 'Rouge', hex: 0xef4444, cssClass: 'color-red' },
  { name: 'Jaune', hex: 0xfbbf24, cssClass: 'color-yellow' },
  { name: 'Vert', hex: 0x22c55e, cssClass: 'color-green' },
  { name: 'Bleu', hex: 0x3b82f6, cssClass: 'color-blue' },
  { name: 'Violet', hex: 0xa855f7, cssClass: 'color-violet' },
  { name: 'Orange', hex: 0xf97316, cssClass: 'color-orange' },
  { name: 'Rose', hex: 0xec4899, cssClass: 'color-pink' },
  { name: 'Cyan', hex: 0x06b6d4, cssClass: 'color-cyan' }
];

// Variables globales
const container = document.getElementById('container');
let scene, camera, renderer, controls;
let pawns = [];
let currentPlayerIndex = 0;
let diceValue = 0;
let gameState = 'waiting';

// Configuration UI
const playerOptions = document.querySelectorAll('.player-option');
playerOptions.forEach(option => {
  option.addEventListener('click', () => {
    playerOptions.forEach(o => o.classList.remove('selected'));
    option.classList.add('selected');
    gameConfig.numPlayers = parseInt(option.dataset.players);
  });
});

document.getElementById('pawnsSlider').addEventListener('input', (e) => {
  gameConfig.pawnsPerPlayer = parseInt(e.target.value);
  document.getElementById('pawnsValue').textContent = e.target.value;
});

document.getElementById('pathSlider').addEventListener('input', (e) => {
  gameConfig.pathLength = parseInt(e.target.value);
  document.getElementById('pathValue').textContent = e.target.value;
});

document.getElementById('startGameBtn').addEventListener('click', () => {
  document.getElementById('configOverlay').classList.add('hidden');
  document.getElementById('container').classList.add('visible');
  initGame();
});

document.getElementById('reconfigBtn').addEventListener('click', () => {
  location.reload();
});

function initGame() {
  scene = new THREE.Scene();
  scene.fog = new THREE.Fog(0x0f1724, 30, 80);
  
  camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
  
  const isMobile = window.innerWidth < 768;
  if (isMobile) {
    camera.position.set(0, 32, 25);
  } else {
    camera.position.set(0, 28, 22);
  }

  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  container.appendChild(renderer.domElement);

  controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;
  controls.target.set(0, 0, 0);
  controls.maxPolarAngle = Math.PI / 2.2;
  controls.minDistance = isMobile ? 18 : 15;
  controls.maxDistance = isMobile ? 60 : 50;
  controls.touches = {
    ONE: THREE.TOUCH.ROTATE,
    TWO: THREE.TOUCH.DOLLY_PAN
  };

  setupLights();
  createBoard();
  setupEventListeners();
  animate();
  updatePlayerTurn();
}

function setupLights() {
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
  scene.add(ambientLight);

  const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
  mainLight.position.set(10, 25, 10);
  mainLight.castShadow = true;
  mainLight.shadow.mapSize.width = 2048;
  mainLight.shadow.mapSize.height = 2048;
  mainLight.shadow.camera.near = 0.5;
  mainLight.shadow.camera.far = 50;
  mainLight.shadow.camera.left = -30;
  mainLight.shadow.camera.right = 30;
  mainLight.shadow.camera.top = 30;
  mainLight.shadow.camera.bottom = -30;
  scene.add(mainLight);

  const fillLight = new THREE.DirectionalLight(0x4a90e2, 0.3);
  fillLight.position.set(-10, 15, -10);
  scene.add(fillLight);
}

function createBoard() {
  const SIZE = 15;
  const TILE = 1;
  
  const floorGeo = new THREE.PlaneGeometry(SIZE * TILE + 10, SIZE * TILE + 10);
  const floorMat = new THREE.MeshStandardMaterial({
    color: 0x0a1220,
    metalness: 0.2,
    roughness: 0.8
  });
  const floor = new THREE.Mesh(floorGeo, floorMat);
  floor.rotation.x = -Math.PI / 2;
  floor.position.y = -0.5;
  floor.receiveShadow = true;
  scene.add(floor);

  // Base du plateau
  const boardBase = new THREE.Group();
  const baseGeo = new THREE.BoxGeometry(SIZE * TILE + 1, 0.8, SIZE * TILE + 1);
  const baseMat = new THREE.MeshStandardMaterial({
    color: 0x1e293b,
    metalness: 0.3,
    roughness: 0.7
  });
  const base = new THREE.Mesh(baseGeo, baseMat);
  base.position.y = -0.4;
  base.castShadow = true;
  base.receiveShadow = true;
  boardBase.add(base);

  // Bordure
  const borderGeo = new THREE.BoxGeometry(SIZE * TILE + 1.2, 0.3, SIZE * TILE + 1.2);
  const borderMat = new THREE.MeshStandardMaterial({
    color: 0xfbbf24,
    metalness: 0.8,
    roughness: 0.2
  });
  const border = new THREE.Mesh(borderGeo, borderMat);
  border.position.y = -0.05;
  border.castShadow = true;
  boardBase.add(border);
  scene.add(boardBase);

  createGameTiles(SIZE, TILE);
  createPlayerBases(SIZE, TILE);
  createCenterDecoration();
}

function toPos(col, row) {
  const SIZE = 15;
  const TILE = 1;
  const x = (col - (SIZE + 1) / 2) * TILE;
  const z = (row - (SIZE + 1) / 2) * TILE;
  return { x, z };
}

function determineTileColor(c, r) {
  const COLORS = {
    red: 0xef4444,
    yellow: 0xfbbf24,
    green: 0x22c55e,
    blue: 0x3b82f6,
    path: 0xf8fafc,
    dark: 0x1e293b
  };
  
  if (c >= 1 && c <= 6 && r >= 1 && r <= 6) return COLORS.red;
  if (c >= 10 && c <= 15 && r >= 1 && r <= 6) return COLORS.yellow;
  if (c >= 1 && c <= 6 && r >= 10 && r <= 15) return COLORS.green;
  if (c >= 10 && c <= 15 && r >= 10 && r <= 15) return COLORS.blue;
  if (c >= 7 && c <= 9 && r >= 7 && r <= 9) return 0xffffff;

  if (r === 8 && c >= 2 && c <= 6) return 0xfecaca;
  if (r === 8 && c >= 10 && c <= 14) return 0xfef3c7;
  if (c === 8 && r >= 10 && r <= 14) return 0xd1fae5;
  if (c === 8 && r >= 2 && r <= 6) return 0xdbeafe;

  return COLORS.path;
}

function isSpecialTile(c, r) {
  return (c === 7 && r === 2) || (c === 2 && r === 9) ||
         (c === 14 && r === 7) || (c === 9 && r === 14);
}

function isStarTile(c, r) {
  return (c === 7 && r === 3) || (c === 3 && r === 9) ||
         (c === 13 && r === 7) || (c === 9 && r === 13) ||
         (c === 2 && r === 7) || (c === 7 && r === 2) ||
         (c === 14 && r === 9) || (c === 9 && r === 14);
}

function createGameTiles(SIZE, TILE) {
  const tileGroup = new THREE.Group();
  for (let r = 1; r <= SIZE; r++) {
    for (let c = 1; c <= SIZE; c++) {
      const { x, z } = toPos(c, r);
      const height = isSpecialTile(c, r) ? 0.18 : 0.12;
      const geom = new THREE.BoxGeometry(TILE * 0.96, height, TILE * 0.96);
      const color = determineTileColor(c, r);
      const mat = new THREE.MeshStandardMaterial({
        color,
        metalness: 0.1,
        roughness: 0.6
      });
      const tile = new THREE.Mesh(geom, mat);
      tile.position.set(x, height / 2, z);
      tile.castShadow = true;
      tile.receiveShadow = true;
      tileGroup.add(tile);

      if (isStarTile(c, r)) {
        createStarMarker(x, height + 0.01, z, tileGroup);
      }
    }
  }
  scene.add(tileGroup);
}

function createStarMarker(x, y, z, parent) {
  const starShape = new THREE.Shape();
  const outerRadius = 0.15;
  const innerRadius = 0.06;
  for (let i = 0; i < 10; i++) {
    const radius = i % 2 === 0 ? outerRadius : innerRadius;
    const angle = (i / 10) * Math.PI * 2;
    const px = Math.cos(angle) * radius;
    const py = Math.sin(angle) * radius;
    if (i === 0) starShape.moveTo(px, py);
    else starShape.lineTo(px, py);
  }
  starShape.closePath();

  const starGeo = new THREE.ShapeGeometry(starShape);
  const starMat = new THREE.MeshStandardMaterial({
    color: 0xfbbf24,
    metalness: 0.8,
    roughness: 0.2
  });
  const star = new THREE.Mesh(starGeo, starMat);
  star.rotation.x = -Math.PI / 2;
  star.position.set(x, y, z);
  parent.add(star);
}

function createPlayerBases(SIZE, TILE) {
  const baseDefs = [
    { name: 'red', cols: [1, 6], rows: [1, 6], color: PLAYER_COLORS[0].hex },
    { name: 'yellow', cols: [10, 15], rows: [1, 6], color: PLAYER_COLORS[1].hex },
    { name: 'green', cols: [1, 6], rows: [10, 15], color: PLAYER_COLORS[2].hex },
    { name: 'blue', cols: [10, 15], rows: [10, 15], color: PLAYER_COLORS[3].hex }
  ];

  baseDefs.forEach((def, baseIndex) => {
    const minC = def.cols[0], maxC = def.cols[1];
    const minR = def.rows[0], maxR = def.rows[1];
    const centerCol = (minC + maxC) / 2;
    const centerRow = (minR + maxR) / 2;
    const p = toPos(centerCol, centerRow);
    const bw = (maxC - minC + 1) * TILE;
    const bh = (maxR - minR + 1) * TILE;

    // Plateforme
    const geo = new THREE.BoxGeometry(bw * 0.92, 0.7, bh * 0.92);
    const mat = new THREE.MeshStandardMaterial({
      color: def.color,
      roughness: 0.4,
      metalness: 0.2
    });
    const platform = new THREE.Mesh(geo, mat);
    platform.position.set(p.x, 0.35, p.z);
    platform.castShadow = true;
    scene.add(platform);

    // Lumi√®re
    const baseLight = new THREE.PointLight(def.color, 0.3, 8);
    baseLight.position.set(p.x, 1, p.z);
    scene.add(baseLight);

    // Spawns
    const spawnOffsets = [
      [-1, -1], [1, -1], [-1, 1], [1, 1]
    ];
    spawnOffsets.forEach((so, i) => {
      const sx = p.x + so[0] * 1.2;
      const sz = p.z + so[1] * 1.2;

      const circleGeo = new THREE.CylinderGeometry(0.38, 0.38, 0.08, 32);
      const circleMat = new THREE.MeshStandardMaterial({
        color: 0x347589,
        metalness: 0.5,
        roughness: 0.3
      });
      const mark = new THREE.Mesh(circleGeo, circleMat);
      mark.position.set(sx, 0.4, sz);
      mark.castShadow = true;
      scene.add(mark);

      const pawn = createPawn(def.color);
      pawn.position.set(sx, 0.75, sz);
      scene.add(pawn);
      pawns.push({ 
        mesh: pawn, 
        playerIndex: baseIndex,
        colorName: PLAYER_COLORS[baseIndex].name,
        cssClass: PLAYER_COLORS[baseIndex].cssClass,
        colorHex: def.color,
        home: { x: sx, z: sz },
        id: baseIndex * 4 + i,
        inPlay: false,
        animating: false
      });
    });
  });
}

function createPawn(color) {
  const group = new THREE.Group();

  const bodyGeo = new THREE.CylinderGeometry(0.28, 0.36, 0.65, 32);
  const bodyMat = new THREE.MeshStandardMaterial({
    color,
    metalness: 0.3,
    roughness: 0.5
  });
  const body = new THREE.Mesh(bodyGeo, bodyMat);
  body.castShadow = true;
  group.add(body);

  const headGeo = new THREE.SphereGeometry(0.22, 32, 32);
  const head = new THREE.Mesh(headGeo, bodyMat);
  head.position.y = 0.5;
  head.castShadow = true;
  group.add(head);

  return group;
}

function createCenterDecoration() {
  const triSize = 2.4;
  const positions = [
    { x: -1.2, z: -1.2, rot: Math.PI * 0.25, color: 0xef4444 },
    { x: 1.2, z: -1.2, rot: Math.PI * -0.25, color: 0xfbbf24 },
    { x: -1.2, z: 1.2, rot: Math.PI * 0.75, color: 0x22c55e },
    { x: 1.2, z: 1.2, rot: Math.PI * -0.75, color: 0x3b82f6 }
  ];

  positions.forEach(pos => {
    const triGeo = new THREE.CylinderGeometry(0, triSize, 0.15, 3);
    const triMat = new THREE.MeshStandardMaterial({
      color: pos.color,
      metalness: 0.4,
      roughness: 0.6
    });
    const tri = new THREE.Mesh(triGeo, triMat);
    tri.position.set(pos.x, 0.08, pos.z);
    tri.rotation.y = pos.rot;
    tri.castShadow = true;
    scene.add(tri);
  });

  const circGeo = new THREE.CylinderGeometry(0.7, 0.7, 0.12, 32);
  const circMat = new THREE.MeshStandardMaterial({
    color: 0x000000,
    metalness: 0.6,
    roughness: 0.3
  });
  const circ = new THREE.Mesh(circGeo, circMat);
  circ.position.set(0, 0.1, 0);
  circ.castShadow = true;
  scene.add(circ);
}

function animate() {
  requestAnimationFrame(animate);
  const elapsed = performance.now() * 0.001;

  pawns.forEach((p, i) => {
    if (!p.animating) {
      p.mesh.position.y = p.inPlay ? p.mesh.position.y : 0.7 + Math.sin(elapsed * 2 + i) * 0.03;
      p.mesh.rotation.y = elapsed * 0.5 + i;
    }
  });

  controls.update();
  renderer.render(scene, camera);
}

function setupEventListeners() {
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  document.getElementById('resetBtn').addEventListener('click', () => {
    const isMob = window.innerWidth < 768;
    camera.position.set(0, isMob ? 32 : 28, isMob ? 25 : 22);
    controls.target.set(0, 0, 0);
  });

  document.getElementById('diceBtn').addEventListener('click', () => {
    if (gameState !== 'waiting') return;
    
    const btn = document.getElementById('diceBtn');
    btn.disabled = true;
    
    let rolls = 0;
    const rollInterval = setInterval(() => {
      diceValue = Math.floor(Math.random() * 6) + 1;
      document.getElementById('diceValue').textContent = diceValue;
      rolls++;
      
      if (rolls >= 10) {
        clearInterval(rollInterval);
        gameState = 'rolled';
        btn.disabled = false;
        showPawnSelector();
      }
    }, 100);
  });
}

function showPawnSelector() {
  const selector = document.getElementById('pawnSelector');
  selector.innerHTML = '';
  
  const availablePawns = pawns.filter(p => p.playerIndex === currentPlayerIndex);
  
  availablePawns.forEach((pawn, index) => {
    const btn = document.createElement('button');
    btn.className = 'pawn-btn';
    btn.style.background = `linear-gradient(135deg, ${rgbToHex(pawn.colorHex)} 0%, ${darkenColor(pawn.colorHex)} 100%)`;
    btn.textContent = `P${index + 1}`;
    btn.addEventListener('click', () => movePawn(pawn));
    selector.appendChild(btn);
  });
}

function movePawn(pawn) {
  if (gameState !== 'rolled') return;
  
  gameState = 'moving';
  document.getElementById('pawnSelector').innerHTML = '';
  
  if (!pawn.inPlay && diceValue === 6) {
    const startPos = getStartPosition(pawn.playerIndex);
    animatePawnMovement(pawn, startPos.x, startPos.z, () => {
      pawn.inPlay = true;
      nextTurn();
    });
  } else if (pawn.inPlay) {
    const currentPos = pawn.mesh.position;
    const newX = currentPos.x + (Math.random() - 0.5) * diceValue * 0.5;
    const newZ = currentPos.z + (Math.random() - 0.5) * diceValue * 0.5;
    
    animatePawnMovement(pawn, newX, newZ, () => {
      nextTurn();
    });
  } else {
    const diceDisplay = document.getElementById('diceValue');
    diceDisplay.classList.add('shake');
    setTimeout(() => diceDisplay.classList.remove('shake'), 300);
    nextTurn();
  }
}

function getStartPosition(playerIndex) {
  const startPositions = [
    { x: -6, z: -6.5 },     // red
    { x: 6, z: -6.5 },      // yellow
    { x: -6, z: 6.5 },      // green
    { x: 6, z: 6.5 }        // blue
  ];
  return startPositions[playerIndex];
}

function animatePawnMovement(pawn, targetX, targetZ, callback) {
  pawn.animating = true;
  const startX = pawn.mesh.position.x;
  const startZ = pawn.mesh.position.z;
  const startY = pawn.mesh.position.y;
  const jumpHeight = 2;
  const duration = 800;
  const startTime = Date.now();

  function move() {
    const elapsed = Date.now() - startTime;
    const progress = Math.min(elapsed / duration, 1);
    const easeProgress = progress < 0.5
      ? 2 * progress * progress
      : 1 - Math.pow(-2 * progress + 2, 2) / 2;

    pawn.mesh.position.x = startX + (targetX - startX) * easeProgress;
    pawn.mesh.position.z = startZ + (targetZ - startZ) * easeProgress;
    pawn.mesh.position.y = startY + Math.sin(easeProgress * Math.PI) * jumpHeight;

    if (progress < 1) {
      requestAnimationFrame(move);
    } else {
      pawn.mesh.position.y = startY;
      pawn.animating = false;
      if (callback) callback();
    }
  }
  move();
}

function nextTurn() {
  if (diceValue !== 6) {
    currentPlayerIndex = (currentPlayerIndex + 1) % gameConfig.numPlayers;
  }
  
  updatePlayerTurn();
  
  diceValue = 0;
  document.getElementById('diceValue').textContent = '-';
  gameState = 'waiting';
}

function updatePlayerTurn() {
  const currentPlayer = PLAYER_COLORS[currentPlayerIndex];
  const playerSpan = document.getElementById('currentPlayer');
  playerSpan.textContent = currentPlayer.name;
  playerSpan.className = currentPlayer.cssClass;
}

function rgbToHex(hex) {
  return '#' + hex.toString(16).padStart(6, '0');
}

function darkenColor(hex) {
  const r = (hex >> 16) & 0xff;
  const g = (hex >> 8) & 0xff;
  const b = hex & 0xff;
  return '#' + ((r * 0.7) << 16 | (g * 0.7) << 8 | (b * 0.7)).toString(16).padStart(6, '0');
}
</script>
</body>
</html>